/******************************************************************************

 @File         PVRTLoadPVG.cpp

 @Title        PVRTLoadPVG

 @Copyright    Copyright (C)  Imagination Technologies Limited.

 @Platform     ANSI Independant

 @Description  Load and display a PVG file. PVG files are generated by PowerVR
               plug-in for Adobe Illustrator (PVRVecEx). This plug-in converts
               Illustrator vector graphic data in a format that matches very
               closely OpenVG data structures.

******************************************************************************/
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <math.h>

#include "pvg.h"			// Interface with file exported from Illustrator
#include "PVRTLoadPVG.h"	// Interface with the user
#include "../PVRTResourceFile.h"

#undef OUTPUT_PATH_DATA

#ifndef PVRT_MAX
#define PVRT_MAX(a,b)	(((a) > (b)) ? (a) : (b))
#endif

#ifndef PVRT_MIN
#define PVRT_MIN(a,b)	(((a) < (b)) ? (a) : (b))
#endif

/*!***************************************************************************
 @Function		CPVRTPVGObject
 @Description	CPVRTPVGObject class constructor where global variables are set up
*****************************************************************************/
CPVRTPVGObject::CPVRTPVGObject() :
	m_bInitialized(false), m_pPaths(NULL),
	m_fLeft(0), m_fTop(0), m_fRight(0), m_fBottom(0),
	m_i32NumPaths(0)
{
}

/*!***************************************************************************
 @Function		~CPVRTPVGObject
 @Description	CPVRTPVGObject class destructor where Paths and Paints are deallocated
*****************************************************************************/
CPVRTPVGObject::~CPVRTPVGObject()
{
	if(m_bInitialized)
	{
		m_bInitialized = false;

		for(int i = 0; i < m_i32NumPaints; ++i)
		{
			vgDestroyPaint(m_pPaints[i]);
		}

		for(int j = 0; j < m_i32NumPaths; ++j)
		{
			vgDestroyPath(m_pPaths[j].m_path);
		}

		free(m_pPaths);
		free(m_pPaints);
	}
}

/*!***************************************************************************
@Function		FromFile
@Input			pszFilepath
@Returns		A PVG Object
@Description	Load a PVG file and sent it for processing.
*****************************************************************************/
CPVRTPVGObject* CPVRTPVGObject::FromFile(const char* pszFilepath)
{
	CPVRTResourceFile PVGFile(pszFilepath);

	if(!PVGFile.IsOpen())
		return 0;

	CPVRTPVGObject* pOvgObj = FromMemoryBuffer((unsigned char*) PVGFile.DataPtr(), (int) PVGFile.Size());

	PVGFile.Close();

	return pOvgObj;
}

/*!***************************************************************************
 @Function		FromMemoryBuffer
 @Input			pui8Buffer Data buffer
 @Input			i32Size	   Size of buffer
 @Returns		A PVG Object
 @Description	Load a PVG data block from memory and send it for processing.
*****************************************************************************/
CPVRTPVGObject* CPVRTPVGObject::FromMemoryBuffer(unsigned char* pui8Buffer, int i32Size)
{
	CPVRTPVGObject* pOvgObj = new CPVRTPVGObject();
	if(!pOvgObj)
	{
		return NULL;
	}
	if(!pOvgObj->LoadMemoryBuffer(pui8Buffer, i32Size))
	{
		delete pOvgObj;
		return NULL;
	}
	return pOvgObj;
}

/*!***************************************************************************
 @Function		LoadMemoryBuffer
 @Input			pui8DataFile Data Buffer
 @Input			i32FileSize	 Size of buffer
 @Returns 		True on success
 @Description	Process a PVG data block.
*****************************************************************************/
bool CPVRTPVGObject::LoadMemoryBuffer(unsigned char* pui8DataFile, int i32FileSize)
{
	vgGetError();//Clear any errors

	PVG_FILE_HEADER* pFileHeader;
	struct COLOURRAMP {unsigned int NumStops; float *pfData;} *Ramps;
	int i32FileOffset = 0;
	unsigned int	ui32;
	int				i32;

	// Get the file header
	pFileHeader = (PVG_FILE_HEADER*)pui8DataFile;

	// Check that this file is a correct one
	if (pFileHeader->dwMagicToken != 'POVG')
	{
		return false;
	}

	// Fill dimensions
	m_fLeft = pFileHeader->fLeft;
	m_fTop = pFileHeader->fTop;
	m_fRight = pFileHeader->fRight;
	m_fBottom = pFileHeader->fBottom;
	m_fWidth = (float)fabs(m_fRight - m_fLeft);
	m_fHeight = (float)fabs(m_fBottom - m_fTop);

	// Increase the file pointer
	i32FileOffset = sizeof(PVG_FILE_HEADER);

	// Allocate structures
	m_i32NumPaths = pFileHeader->dwNumPaths;
	m_pPaths = (PathData*)malloc(pFileHeader->dwNumPaths * sizeof(PathData));
	m_i32NumPaints = pFileHeader->dwNumPaints;
	m_pPaints = (VGPaint *)malloc(m_i32NumPaints * sizeof(VGPaint));

	//////////////////////////////////////////////////////
    // Get all colour ramps (if any)
	// These are stored secuentially after the FileHeader
	// DWORD NumStops, FLOAT 5*NumStops
	//////////////////////////////////////////////////////
	Ramps = (COLOURRAMP *) malloc (sizeof(COLOURRAMP)*pFileHeader->dwNumRamps);

	for (ui32=0; ui32<pFileHeader->dwNumRamps; ui32++)
	{
		Ramps[ui32].NumStops = *((unsigned int *)(pui8DataFile + i32FileOffset));
		i32FileOffset += sizeof(unsigned);

		Ramps[ui32].pfData = (float *)(pui8DataFile + i32FileOffset);
		i32FileOffset += Ramps[ui32].NumStops * sizeof(float)*5;
	}

	////////////////////////////////////////////////////////
	// Get all paints
	// These are stored secuentially after the colour ramps
	// PVG_PAINT_HEADER
	////////////////////////////////////////////////////////
	for (i32=0; i32<m_i32NumPaints; i32++)
	{
		m_pPaints[i32] = vgCreatePaint();
		PVG_PAINT_HEADER *sFilePaintData = (PVG_PAINT_HEADER *)(pui8DataFile + i32FileOffset);

		vgSetParameteri(m_pPaints[i32], VG_PAINT_TYPE, sFilePaintData->dwPaintStyle);

		switch (sFilePaintData->dwPaintStyle)
		{
			case VG_PAINT_TYPE_LINEAR_GRADIENT:
			{
				COLOURRAMP sCurrentRamp = Ramps[sFilePaintData->dwRamp];
				vgSetParameterfv(m_pPaints[i32], VG_PAINT_LINEAR_GRADIENT, 4, sFilePaintData->fPaintParameters);
				vgSetParameteri(m_pPaints[i32], VG_PAINT_COLOR_RAMP_SPREAD_MODE, VG_COLOR_RAMP_SPREAD_PAD);
				vgSetParameterfv(m_pPaints[i32], VG_PAINT_COLOR_RAMP_STOPS, sCurrentRamp.NumStops*5, sCurrentRamp.pfData);
				break;
			}
			case VG_PAINT_TYPE_RADIAL_GRADIENT:
			{
				COLOURRAMP sCurrentRamp = Ramps[sFilePaintData->dwRamp];
				vgSetParameterfv(m_pPaints[i32], VG_PAINT_RADIAL_GRADIENT, 5, sFilePaintData->fPaintParameters);
				vgSetParameteri(m_pPaints[i32], VG_PAINT_COLOR_RAMP_SPREAD_MODE, VG_COLOR_RAMP_SPREAD_PAD);
				vgSetParameterfv(m_pPaints[i32], VG_PAINT_COLOR_RAMP_STOPS, sCurrentRamp.NumStops*5, sCurrentRamp.pfData);
				break;
			}
			case VG_PAINT_TYPE_PATTERN:
			case VG_PAINT_TYPE_COLOR:
			default:
			{
				vgSetParameteri(m_pPaints[i32], VG_PAINT_TYPE, VG_PAINT_TYPE_COLOR);
				vgSetParameterfv(m_pPaints[i32], VG_PAINT_COLOR, 4, sFilePaintData->fPaintParameters);
				break;
			}
		}

		if(vgGetError() != VG_NO_ERROR)
		{
			// Free ramps list. This is not needed any more
			free(Ramps);
			return false;
		}

		// Increase the offset to point to the next paint (the size of a paint is the size of the paint header)
		i32FileOffset += sizeof(PVG_PAINT_HEADER);
	}

	// Free ramps list. This is not needed any more
	free(Ramps);

	////////////////////////////////////////////////////////
	// Get all Paths
	// These are stored secuentially after the Paints
	// PVG_PATH_HEADER, BYTE Commands, FLOAT Points
	////////////////////////////////////////////////////////
	for (i32=0; i32<m_i32NumPaths; i32++)
	{
		PVG_PATH_HEADER *sFilepathData = (PVG_PATH_HEADER *)(pui8DataFile + i32FileOffset);

		// Fill structure from file
		m_pPaths[i32].m_fillRule		=  (VGFillRule)  sFilepathData->dwFillRule;
		m_pPaths[i32].m_paintMode		=  (VGPaintMode) sFilepathData->dwPathType;
		m_pPaths[i32].m_capStyle		=  (VGCapStyle)  sFilepathData->dwStrokeCap;
		m_pPaths[i32].m_joinStyle		=  (VGJoinStyle) sFilepathData->dwStrokeJoin;
		m_pPaths[i32].m_fMiterLimit		=  sFilepathData->fStrokeMiterLimit;
		m_pPaths[i32].m_fStrokeWidth	=  sFilepathData->fStrokeWidth;
		m_pPaths[i32].m_strokePaint		=  (m_pPaths[i32].m_paintMode & VG_STROKE_PATH) ?	m_pPaints[sFilepathData->StrokePaint] : (VGPaint)NULL;
		m_pPaths[i32].m_fillPaint		=  (m_pPaths[i32].m_paintMode & VG_FILL_PATH) ?	m_pPaints[sFilepathData->FillPaint] : (VGPaint)NULL;
		m_pPaths[i32].m_ui32DashID		=	sFilepathData->StrokeDash; // 666 for none
		m_pPaths[i32].m_bIsNewFill		=  (i32==0 || (m_pPaths[i32].m_fillPaint!=m_pPaths[i32-1].m_fillPaint)) ? 1:0;
		m_pPaths[i32].m_bNeedsBlending	= (sFilepathData->dwAlphaBlend) ? 1:0;
		m_pPaths[i32].m_bIsNewStroke	=  (i32==0 || (m_pPaths[i32].m_strokePaint!=m_pPaths[i32-1].m_strokePaint)
			                                 || (m_pPaths[i32].m_ui32DashID!=m_pPaths[i32-1].m_ui32DashID)
											 || (m_pPaths[i32].m_fStrokeWidth!=m_pPaths[i32-1].m_fStrokeWidth)) ? 1 :0;

		// Create Path
		m_pPaths[i32].m_path = vgCreatePath(VG_PATH_FORMAT_STANDARD, VG_PATH_DATATYPE_F,
												1.0f, 0.0f, 0, 0, (unsigned int)VG_PATH_CAPABILITY_ALL);

		// Commands (after header)
		i32FileOffset += sizeof(PVG_PATH_HEADER);
		VGubyte *pui8Cmd = (VGubyte *)(pui8DataFile + i32FileOffset);

		// Data (after commands)
		i32FileOffset += ((sFilepathData->dwNumSegments/4)+1)*4; // Commands size is 1 byte per command/segments and it is 32bits aligned in size
		float *pfPoints = (float *)(pui8DataFile + i32FileOffset);

		// Store the path
		vgAppendPathData(m_pPaths[i32].m_path, sFilepathData->dwNumSegments, pui8Cmd, pfPoints);

		// Move to the next path
		i32FileOffset += sFilepathData->dwPathDataSize; // Data size is variable depending of the tipe of segment

		if(vgGetError() != VG_NO_ERROR)
		{
			return false;
		}
	}

	////////////////////////////////////////////////////////
	// Get all stroke Dashes
	// These are stored secuentially after the Paths in the PVG file
	// In this case we fill in the variables inside our path structure
	// to be used later, once we are going to draw the path.
	////////////////////////////////////////////////////////
	for (i32=0; i32<m_i32NumPaths; i32++)
	{
		unsigned int ui32CurrentDash = m_pPaths[i32].m_ui32DashID;

		if(ui32CurrentDash != 666 && ui32CurrentDash<pFileHeader->dwNumDashes) // This path does not have a dashed stroke
		{
			// Point to the dash
			float *pMem = (float *)(pui8DataFile + i32FileOffset + ui32CurrentDash*sizeof(PVG_DASH_HEADER));

			// Fill in the data
			m_pPaths[i32].m_ui32NumDashes = *((unsigned int *)pMem++);
			m_pPaths[i32].m_fDashPhase = *pMem++;
			for (int i=0; i<6; i++) m_pPaths[i32].m_fDashValues[i] = *pMem++;
		}
		else
		{
			m_pPaths[i32].m_ui32DashID = 666; // cancel this dash
		}
	}

	// Increase offset
	i32FileOffset += pFileHeader->dwNumDashes*sizeof(PVG_DASH_HEADER);

	// Load successful.
	m_bInitialized = true;

	return true;
}

/*!***************************************************************************
 @Function		Draw
 @Input			i32StartPath Path to start drawing from
 @Input			i32EndPath	Path to end drawing on
 @Returns		True on success
 @Description	Draw a set of the paths loaded from the file. If no argument
				is specified this function will draw all paths.
*****************************************************************************/
bool CPVRTPVGObject::Draw(int i32StartPath, int i32EndPath)
{
	if (!m_bInitialized)
	{
		// This set has not been initialised so return.
		return false;
	}

	if(i32EndPath < i32StartPath)
	{
		i32EndPath = m_i32NumPaths;
	}

	i32StartPath = PVRT_MAX(0, i32StartPath);
	i32EndPath = PVRT_MIN(i32EndPath, m_i32NumPaths);

	for(int i = i32StartPath; i < i32EndPath; ++i)
	{
		// Set the blending options. PVG files only support standard translucency.
		if(m_pPaths[i].m_bNeedsBlending)
		{
			vgSeti(VG_BLEND_MODE, VG_BLEND_SRC_OVER);
		}
		else
		{
			vgSeti(VG_BLEND_MODE, VG_BLEND_SRC);
		}

		// Check whether this one is a path without fill or stroke and ignore it.
		if(m_pPaths[i].m_paintMode == 0)
		{
			continue;
		}

		// Fill the parameters for the current Fill Paint
		// Check if the paint is present, if it is different than the previous one or if it is the first one.
		if(((m_pPaths[i].m_paintMode & VG_FILL_PATH) && m_pPaths[i].m_bIsNewFill) || (i==i32StartPath))
		{
			vgSeti(VG_FILL_RULE, m_pPaths[i].m_fillRule);

			vgSetPaint(m_pPaths[i].m_fillPaint, VG_FILL_PATH);
		}

		// Fill the parameters for the current Stroke Paint
		if(((m_pPaths[i].m_paintMode & VG_STROKE_PATH) && m_pPaths[i].m_bIsNewStroke) || (i==i32StartPath))
        {
			vgSetf(VG_STROKE_LINE_WIDTH, m_pPaths[i].m_fStrokeWidth);
			vgSeti(VG_STROKE_CAP_STYLE,	 m_pPaths[i].m_capStyle);
			vgSeti(VG_STROKE_JOIN_STYLE, m_pPaths[i].m_joinStyle);
			vgSetf(VG_STROKE_MITER_LIMIT,m_pPaths[i].m_fMiterLimit);

			// Get current stroke 'dash' if any
			if (m_pPaths[i].m_ui32DashID != 666)
			{
				vgSetf(VG_STROKE_DASH_PHASE, m_pPaths[i].m_fDashPhase);
				vgSetfv(VG_STROKE_DASH_PATTERN, m_pPaths[i].m_ui32NumDashes, m_pPaths[i].m_fDashValues);
			}
			else
			{
				vgSetfv(VG_STROKE_DASH_PATTERN, 0, (VGfloat *) 0); // disable dashes
			}

 			vgSetPaint(m_pPaths[i].m_strokePaint, VG_STROKE_PATH);
        }

		// Draw this path.
		vgDrawPath(m_pPaths[i].m_path, m_pPaths[i].m_paintMode);
	}

	// Success!
	return true;
}

/*!***************************************************************************
 @Function		SetAlpha
 @Input			ui8Alpha (0x00 = Fuly translucent, 0xFF = fully opaque)
 @Description	Overwrites path translucency parameter
*****************************************************************************/
void CPVRTPVGObject::SetAlpha(unsigned char ui8Alpha)
{
	assert(m_bInitialized);
	int i32Color;
	for(int i = 0; i < m_i32NumPaths; ++i)
	{
		if(m_pPaths[i].m_bIsNewFill)
		{
			i32Color = (vgGetColor(m_pPaths[i].m_fillPaint) & 0xFFFFFF00) + ui8Alpha;
			vgSetColor(m_pPaths[i].m_fillPaint, i32Color);
		}
		if(m_pPaths[i].m_bIsNewStroke)
		{
			i32Color = (vgGetColor(m_pPaths[i].m_strokePaint) & 0xFFFFFF00) + ui8Alpha;
			vgSetColor(m_pPaths[i].m_strokePaint, i32Color);
		}
		m_pPaths[i].m_bNeedsBlending = (ui8Alpha != 255);
	}
}
/*!***************************************************************************
 @Function		SetupCenterOnOrigin
 @Description	Move artwork center to origin so full figure is displayed.
*****************************************************************************/
void CPVRTPVGObject::SetupCenterOnOrigin()
{
	vgTranslate(-(m_fLeft + m_fRight) / 2, -(m_fTop + m_fBottom) / 2);
}

/*!***************************************************************************
 @Function		SetupTranslateToOrigin
 @Description	Function used to move the artwork center to the origin of the
				coordinate system so the artwork can be cetered on the screen.
*****************************************************************************/
void CPVRTPVGObject::SetupTranslateToOrigin()
{
	vgTranslate(-m_fLeft, -m_fBottom);
}

/*!***************************************************************************
 @Function		SetupScaleToSize
 @Input			fTargetWidth	Target width to scale to
 @Input			fTargetHeight	Target height to scale to
 @Input			bKeepAspect		Maintain the aspect ratio
 @Description	Function used to fit the artwork on the screen.
*****************************************************************************/
void CPVRTPVGObject::SetupScaleToSize(float fTargetWidth, float fTargetHeight, bool bKeepAspect)
{
	float fScaleH = fTargetWidth / m_fWidth;
	float fScaleV = fTargetHeight / m_fHeight;
	if(bKeepAspect)
	{
		fScaleH = fabs(fScaleH) < fabs(fScaleV) ? fScaleH : fScaleV;
		fScaleV = fScaleH;
	}
	vgScale(fScaleH, fScaleV);
}

/*****************************************************************************
 End of file (PVRTLoadPVG.cpp)
*****************************************************************************/


